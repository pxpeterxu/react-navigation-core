{"version":3,"sources":["routerTestHelper.js"],"names":["defaultOptions","skipInitializeState","getRouterTestHelper","router","options","state","undefined","getStateForAction","type","NavigationActions","INIT","applyAction","action","navigateTo","routeName","otherActionAttributes","NAVIGATE","jumpTo","SwitchActions","JUMP_TO","back","key","BACK","pop","StackActions","POP","popToTop","POP_TO_TOP","getState","getSubState","level","getSubStateRecursive","directSubState","routes","index"],"mappings":"8VAAA,kFACA,kFACA,gFAOA,GAAMA,CAAAA,cAAc,CAAG,CACrBC,mBAAmB,CAAE,KADA,CAAvB,CAIO,GAAMC,CAAAA,mBAAmB,CAAG,QAAtBA,CAAAA,mBAAsB,CAACC,MAAD,CAAsC,IAA7BC,CAAAA,OAA6B,2DAAnBJ,cAAmB,CACvE,GAAIK,CAAAA,KAAK,CACPD,OAAO,EAAIA,OAAO,CAACH,mBAAnB,CACIK,SADJ,CAEIH,MAAM,CAACI,iBAAP,CAAyB,CAAEC,IAAI,CAAEC,iBAAiB,CAACC,IAA1B,CAAzB,CAHN,CAKA,GAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAAAC,MAAM,CAAI,CAC5BP,KAAK,CAAGF,MAAM,CAACI,iBAAP,CAAyBK,MAAzB,CAAiCP,KAAjC,CAAR,CACD,CAFD,CAIA,GAAMQ,CAAAA,UAAU,CAAG,QAAbA,CAAAA,UAAa,CAACC,SAAD,CAAYC,qBAAZ,QACjBJ,CAAAA,WAAW,6BACTH,IAAI,CAAEC,iBAAiB,CAACO,QADf,CAETF,SAAS,CAATA,SAFS,EAGNC,qBAHM,EADM,EAAnB,CAOA,GAAME,CAAAA,MAAM,CAAG,QAATA,CAAAA,MAAS,CAACH,SAAD,CAAYC,qBAAZ,QACbJ,CAAAA,WAAW,6BACTH,IAAI,CAAEU,aAAa,CAACC,OADX,CAETL,SAAS,CAATA,SAFS,EAGNC,qBAHM,EADE,EAAf,CAOA,GAAMK,CAAAA,IAAI,CAAG,QAAPA,CAAAA,IAAO,CAAAC,GAAG,QACdV,CAAAA,WAAW,CAAC,CACVH,IAAI,CAAEC,iBAAiB,CAACa,IADd,CAEVD,GAAG,CAAHA,GAFU,CAAD,CADG,EAAhB,CAMA,GAAME,CAAAA,GAAG,CAAG,QAANA,CAAAA,GAAM,SACVZ,CAAAA,WAAW,CAAC,CACVH,IAAI,CAAEgB,YAAY,CAACC,GADT,CAAD,CADD,EAAZ,CAKA,GAAMC,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,SACff,CAAAA,WAAW,CAAC,CACVH,IAAI,CAAEgB,YAAY,CAACG,UADT,CAAD,CADI,EAAjB,CAKA,GAAMC,CAAAA,QAAQ,CAAG,QAAXA,CAAAA,QAAW,SAAMvB,CAAAA,KAAN,EAAjB,CAEA,GAAMwB,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,EAAe,IAAdC,CAAAA,KAAc,2DAAN,CAAM,CACjC,MAAOC,CAAAA,oBAAoB,CAAC1B,KAAD,CAAQyB,KAAR,CAA3B,CACD,CAFD,CAIA,MAAO,CACLnB,WAAW,CAAXA,WADK,CAELE,UAAU,CAAVA,UAFK,CAGLI,MAAM,CAANA,MAHK,CAILG,IAAI,CAAJA,IAJK,CAKLG,GAAG,CAAHA,GALK,CAMLG,QAAQ,CAARA,QANK,CAOLE,QAAQ,CAARA,QAPK,CAQLC,WAAW,CAAXA,WARK,CAAP,CAUD,CAxDM,C,gDA0DP,GAAME,CAAAA,oBAAoB,CAAG,QAAvBA,CAAAA,oBAAuB,CAAC1B,KAAD,CAAsB,IAAdyB,CAAAA,KAAc,2DAAN,CAAM,CACjD,GAAIA,KAAK,GAAK,CAAd,CAAiB,CACf,MAAOzB,CAAAA,KAAP,CACD,CAFD,IAEO,CACL,GAAM2B,CAAAA,cAAc,CAAG3B,KAAK,CAAC4B,MAAN,CAAa5B,KAAK,CAAC6B,KAAnB,CAAvB,CACA,MAAOH,CAAAA,oBAAoB,CAACC,cAAD,CAAiBF,KAAK,CAAG,CAAzB,CAA3B,CACD,CACF,CAPD","sourcesContent":["import * as NavigationActions from '../../NavigationActions';\nimport * as SwitchActions from '../../routers/SwitchActions';\nimport * as StackActions from '../../routers/StackActions';\n\n// A simple helper that makes it easier to write basic routing tests\n// We generally want to apply one action after the other and check router returns correct state\n// it's often convenient to manipulate a structure that keeps the router state to avoid\n// creating many state1, state2, state3 local variables which are prone to typos...\n\nconst defaultOptions = {\n  skipInitializeState: false,\n};\n\nexport const getRouterTestHelper = (router, options = defaultOptions) => {\n  let state =\n    options && options.skipInitializeState\n      ? undefined\n      : router.getStateForAction({ type: NavigationActions.INIT });\n\n  const applyAction = action => {\n    state = router.getStateForAction(action, state);\n  };\n\n  const navigateTo = (routeName, otherActionAttributes) =>\n    applyAction({\n      type: NavigationActions.NAVIGATE,\n      routeName,\n      ...otherActionAttributes,\n    });\n\n  const jumpTo = (routeName, otherActionAttributes) =>\n    applyAction({\n      type: SwitchActions.JUMP_TO,\n      routeName,\n      ...otherActionAttributes,\n    });\n\n  const back = key =>\n    applyAction({\n      type: NavigationActions.BACK,\n      key,\n    });\n\n  const pop = () =>\n    applyAction({\n      type: StackActions.POP,\n    });\n\n  const popToTop = () =>\n    applyAction({\n      type: StackActions.POP_TO_TOP,\n    });\n\n  const getState = () => state;\n\n  const getSubState = (level = 1) => {\n    return getSubStateRecursive(state, level);\n  };\n\n  return {\n    applyAction,\n    navigateTo,\n    jumpTo,\n    back,\n    pop,\n    popToTop,\n    getState,\n    getSubState,\n  };\n};\n\nconst getSubStateRecursive = (state, level = 1) => {\n  if (level === 0) {\n    return state;\n  } else {\n    const directSubState = state.routes[state.index];\n    return getSubStateRecursive(directSubState, level - 1);\n  }\n};\n"]}