{"version":3,"sources":["routerTestHelper.js"],"names":["NavigationActions","SwitchActions","StackActions","defaultOptions","skipInitializeState","getRouterTestHelper","router","options","state","undefined","getStateForAction","type","INIT","applyAction","action","navigateTo","routeName","otherActionAttributes","NAVIGATE","jumpTo","JUMP_TO","back","key","BACK","pop","POP","popToTop","POP_TO_TOP","getState","getSubState","level","getSubStateRecursive","directSubState","routes","index"],"mappings":"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","sourcesContent":["import * as NavigationActions from '../../NavigationActions';\nimport * as SwitchActions from '../../routers/SwitchActions';\nimport * as StackActions from '../../routers/StackActions';\n\n// A simple helper that makes it easier to write basic routing tests\n// We generally want to apply one action after the other and check router returns correct state\n// it's often convenient to manipulate a structure that keeps the router state to avoid\n// creating many state1, state2, state3 local variables which are prone to typos...\n\nconst defaultOptions = {\n  skipInitializeState: false,\n};\n\nexport const getRouterTestHelper = (router, options = defaultOptions) => {\n  let state =\n    options && options.skipInitializeState\n      ? undefined\n      : router.getStateForAction({ type: NavigationActions.INIT });\n\n  const applyAction = action => {\n    state = router.getStateForAction(action, state);\n  };\n\n  const navigateTo = (routeName, otherActionAttributes) =>\n    applyAction({\n      type: NavigationActions.NAVIGATE,\n      routeName,\n      ...otherActionAttributes,\n    });\n\n  const jumpTo = (routeName, otherActionAttributes) =>\n    applyAction({\n      type: SwitchActions.JUMP_TO,\n      routeName,\n      ...otherActionAttributes,\n    });\n\n  const back = key =>\n    applyAction({\n      type: NavigationActions.BACK,\n      key,\n    });\n\n  const pop = () =>\n    applyAction({\n      type: StackActions.POP,\n    });\n\n  const popToTop = () =>\n    applyAction({\n      type: StackActions.POP_TO_TOP,\n    });\n\n  const getState = () => state;\n\n  const getSubState = (level = 1) => {\n    return getSubStateRecursive(state, level);\n  };\n\n  return {\n    applyAction,\n    navigateTo,\n    jumpTo,\n    back,\n    pop,\n    popToTop,\n    getState,\n    getSubState,\n  };\n};\n\nconst getSubStateRecursive = (state, level = 1) => {\n  if (level === 0) {\n    return state;\n  } else {\n    const directSubState = state.routes[state.index];\n    return getSubStateRecursive(directSubState, level - 1);\n  }\n};\n"]}